import numpy as np

# =============================================================================
# 1. GLOBAL PARAMETERS AND TURBINE CONSTANTS
# Based on the data provided in the paper.
# =============================================================================

D = 40.0      # Turbine rotor diameter (meters)
R = D / 2.0   # Turbine rotor radius (meters)
Z = 60.0      # Turbine hub height (meters)
Zo = 0.3      # Terrain roughness length (meters)
Ct = 0.88     # Thrust coefficient

# Axial induction factor 'a', derived from Ct
# Formula: a = 0.5 * (1 - sqrt(1 - Ct))
a = 0.5 * (1 - np.sqrt(1 - Ct))

# Wake decay constant 'alpha' (also 'k' in other models)
# Formula: alpha = 0.5 / ln(Z / Zo)
alpha = 0.5 / np.log(Z / Zo)


# =============================================================================
# 2. PHYSICS MODEL FUNCTIONS
# =============================================================================

def rotate_coordinates(layout, angle_deg, center):
    """
    Rotates the coordinates of a turbine layout around a central point.
    This is used to align the layout with the wind direction.
    """
    layout_centered = layout - center
    angle_rad = np.radians(angle_deg)
    cos_a, sin_a = np.cos(angle_rad), np.sin(angle_rad)
    rotation_matrix = np.array([[cos_a, -sin_a], [sin_a,  cos_a]])
    rotated_centered_layout = layout_centered @ rotation_matrix.T
    return rotated_centered_layout + center

def get_wake_velocity(u_freestream, x_dist, r_d_wake):
    """
    Calculates the wind speed within a wake at a downwind distance x.
    Implements the Jensen model for a single wake.
    Formula: u = u_0 * (1 - 2a / (1 + alpha * x / r_d)^2)
    """
    denominator = (1 + alpha * (x_dist / r_d_wake))**2
    velocity_deficit = (2 * a) / denominator
    return u_freestream * (1 - velocity_deficit)

def get_power(u):
    """
    Calculates the power generated by a turbine for a given wind speed 'u'.
    Implements the power curve described in Equation (11) of the paper.
    """
    u = np.atleast_1d(u)
    power = np.zeros_like(u, dtype=float)
    
    cut_in_speed = 3.0
    rated_speed = 12.0
    cut_out_speed = 25.0
    rated_power = 518.4  # kW
    
    # Cubic operating range
    mask1 = (u >= cut_in_speed) & (u < rated_speed)
    power[mask1] = 0.3 * u[mask1]**3
    
    # Rated power range
    mask2 = (u >= rated_speed) & (u <= cut_out_speed)
    power[mask2] = rated_power
    
    # Return a single value if the input was a scalar
    return power.item() if power.size == 1 else power


# =============================================================================
# 3. EVALUATION AND OBJECTIVE FUNCTIONS
# =============================================================================

def evaluate_layout_power(layout, wind_direction_deg, u_freestream, farm_dims):
    """
    Evaluates the total power generated by a wind farm layout.
    This function calculates the denominator of the objective function.
    """
    if len(layout) == 0:
        return 0.0
        
    farm_center = np.array([farm_dims[0] / 2, farm_dims[1] / 2])
    
    # Rotate the layout so that the wind comes from the positive Y-axis
    rotated_layout = rotate_coordinates(layout, -wind_direction_deg, center=farm_center)
    
    # Sort turbines from highest to lowest on the Y-axis (from "top" to "bottom")
    sorted_indices = np.argsort(rotated_layout[:, 1])[::-1]
    sorted_rotated_layout = rotated_layout[sorted_indices]
    
    n_turbines = len(sorted_rotated_layout)
    turbine_velocities = np.full(n_turbines, u_freestream)
    
    # Initial expanded wake radius
    # Formula: r_d = R * sqrt((1-a) / (1-2a))
    r_d = R * np.sqrt((1 - a) / (1 - 2 * a))
    
    # Iterate over each turbine to calculate the wind speed reaching it
    for i in range(n_turbines):
        pos_i = sorted_rotated_layout[i]    
        sum_of_squared_deficits = 0.0
        
        # Consider the effect of all upstream turbines (j < i)
        for j in range(i):
            pos_j = sorted_rotated_layout[j]
            dist_downwind = pos_j[1] - pos_i[1]
            
            if dist_downwind > 0:
                dist_crosswind = np.abs(pos_j[0] - pos_i[0])
                
                # Wake radius of turbine 'j' at the distance of turbine 'i'
                wake_radius_at_i = r_d + alpha * dist_downwind
                
                # If turbine 'i' is inside the wake of 'j'
                if dist_crosswind < wake_radius_at_i:
                    # Calculate the velocity deficit caused by turbine j
                    u_wake_base = get_wake_velocity(u_freestream, dist_downwind, r_d)
                    base_deficit = (u_freestream - u_wake_base) / u_freestream
                    sum_of_squared_deficits += base_deficit**2
                    
        # Combine deficits using the sum of squares method
        if sum_of_squared_deficits > 0:
            total_deficit = np.sqrt(sum_of_squared_deficits)
            turbine_velocities[i] = u_freestream * (1 - total_deficit)
            
    # Calculate total power by summing the power of each turbine
    total_power = np.sum(get_power(turbine_velocities))
    return total_power

def get_installation_cost(n_turbines):
    """
    Calculates the total installation cost using Equation (17) from the paper.
    This simulates a volume discount.
    """
    if n_turbines == 0:
        return 0
    # Unit cost per turbine
    unit_cost = (2/3) + (1/3) * np.exp(-0.00174 * n_turbines**2)
    # Total cost
    total_cost = n_turbines * unit_cost
    return total_cost

def objective_function(layout, wind_direction_deg, u_freestream, farm_dims):
    """
    Calculates the complete objective function (Equation 18) to be minimized.
    Ratio: Total Cost / Total Generated Power
    """
    # 1. Calculate the total generated power (denominator)
    total_power = evaluate_layout_power(layout, wind_direction_deg, u_freestream, farm_dims)
    
    # If power is negligible, the design is unfeasible.
    # Return an infinite value so any optimizer will discard it.
    if total_power < 1e-6:
        return float('inf')
        
    # 2. Calculate the total installation cost (numerator)
    n_turbines = len(layout)
    total_cost = get_installation_cost(n_turbines)
    
    # 3. Calculate and return the ratio
    return total_cost / total_power

def create_grid(rows, cols, width, height):
        cell_width = width / cols
        cell_height = height / rows
        x_coords = np.linspace(cell_width / 2, width - cell_width / 2, cols)
        y_coords = np.linspace(cell_height / 2, height - cell_height / 2, rows)
        grid_x, grid_y = np.meshgrid(x_coords, y_coords)
        return np.vstack([grid_x.ravel(), grid_y.ravel()]).T
